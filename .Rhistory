lines(x=c(173750,243250),y=c(0,0),col="red")
lines(x=c(312750,382250),y=c(0,0),col="red")
abline(v=c(34750,104250,173750,243250,312750,382250))
abline(v=c(34750,104250,173750,243250,312750,382250), col="red")
?lines
lines(x=c(34750,104250),y=c(0,0),col="red",lty=2)
lines(x=c(34750,104250),y=c(0,0),col="red",lty=5)
lines(x=c(34750,104250),y=c(0,0),col="red",lwd=5)
# Plot !
manhattan(CHR_data , ylim=c(Min-(Min*0.1),Max+(Max*0.1)), suggestiveline = F, genomewideline = F , logp=F, col=brewer.pal(5, "Set2") , main="Silverside simulation\nm=0.001, r=(1e-5)x4, 1e-6, 1e-4", ylab=expression(paste("F"[ST])))
lines(x=c(34750,104250),y=c(0,0),col="red",lwd=2)
lines(x=c(34750,104250),y=c(Min-(Min*0.1),Min-(Min*0.1)),col="red",lwd=2)
# Plot !
manhattan(CHR_data , ylim=c(Min-(Min*0.1),Max+(Max*0.1)), suggestiveline = F, genomewideline = F , logp=F, col=brewer.pal(5, "Set2") , main="Silverside simulation\nm=0.001, r=(1e-5)x4, 1e-6, 1e-4", ylab=expression(paste("F"[ST])))
lines(x=c(34750,104250),y=c(Min-(Min*0.1),Min-(Min*0.1)),col="red",lwd=2)
abline(v=c(34750,104250,173750,243250,312750,382250), col="red")
ssvcf_clean <- ssvcf[-grep("MT=[2-4]",ssvcf@fix[,8])]
geno <- ssvcf_clean@gt[,-1] # Remove 1st column, which is 'Format'
position <- as.numeric(getPOS(ssvcf_clean)) # Positions in bp
for(i in 1:length(position)){
if(position[i]>34750 & position[i]<104250){
position[i]<-104250-position[i]+34750
}
if(position[i]>173750 & position[i]<243250){
position[i]<-243250-position[i]+173750
}
if(position[i]>312750 & position[i]<382250){
position[i]<-382250-position[i]+312750
}
}
G1 <- matrix(NA, nrow = nrow(geno), ncol = ncol(geno))
G1[geno %in% c("0/0", "0|0")] <- 0
G1[geno %in% c("0/1", "1/0", "1|0", "0|1")] <- 1
G1[geno %in% c("1/1", "1|1")] <- 2
Gt<-t(G1)
colnames(Gt)<-paste("M",position,sep="")
PopsALL <- NULL
for(j in rep(1:2)){
for(i in rep(j,100)){
PopsALL <- c(PopsALL,i)
}
}
position_inv<-NULL
position_scaled<-NULL
for(i in 1:length(position)){
if(position[i]>0 & position[i]<139001){
position_inv<-c(position_inv,1)
position_scaled<-c(position_scaled,position[i])
}
if(position[i]>139000 & position[i]<278001){
position_inv<-c(position_inv,2)
position_scaled<-c(position_scaled,position[i]-139000)
}
if(position[i]>278000 & position[i]<417001){
position_inv<-c(position_inv,3)
position_scaled<-c(position_scaled,position[i]-278000)
}
if(position[i]>417000 & position[i]<556001){
position_inv<-c(position_inv,4)
position_scaled<-c(position_scaled,position[i]-417000)
}
if(position[i]>556000 & position[i]<695001){
position_inv<-c(position_inv,5)
position_scaled<-c(position_scaled,position[i]-556000)
}
if(position[i]>695000 & position[i]<834001){
position_inv<-c(position_inv,6)
position_scaled<-c(position_scaled,position[i]-695000)
}
}
Gtf <- data.frame(Gt)
getFSTs_diploids = function(popNameList, SNPDataColumn){
#eliminating the missing data for this locus
popnames=unlist(as.character(popNameList))
popNameTemp=popnames[which(SNPDataColumn!=9)]
snpDataTemp=SNPDataColumn[SNPDataColumn!=9]
HetCounts <- tapply(snpDataTemp, list(popNameTemp,snpDataTemp), length)
HetCounts[is.na(HetCounts)] = 0
#Case: all individuals are genetically identical at this locus
if(dim(HetCounts)[2]==1){
return (list(He=NA,FST=NA, T1=NA, T2=NA,FSTNoCorr=NA, T1NoCorr=NA, T2NoCorr=NA,meanAlleleFreq = NA))
}
if(dim(HetCounts)[2]==2){
if(paste(colnames(HetCounts),collapse="")=="01"){HetCounts=cbind(HetCounts,"2"=0)}
if(paste(colnames(HetCounts),collapse="")=="12"){HetCounts=cbind("0"=0,HetCounts)}
if(paste(colnames(HetCounts),collapse="")=="02"){HetCounts=cbind(HetCounts[,1],"1"=0, HetCounts[,2])}
}
out = WC_FST_Diploids_2Alleles(HetCounts)
return(out)
}
MakeDiploidFSTMat_2<-function(SNPmat,locusNames,popNames){
locusname <- unlist(locusNames)
popname <- unlist(popNames)
snplevs <- levels(as.factor(unlist(SNPmat)))
if(any(!(snplevs%in%c(0,1,2,9)))==TRUE) {
print("Error: Your snp matrix has a character other than 0,1,2 or 9")
break
}
if (dim(SNPmat)[1] != length(popname)) {
print("Error: your population names do not match your SNP matrix")
break
}
if (dim(SNPmat)[2] != length(locusname)) {
print("Error:  your locus names do not match your SNP matrix")
break
}
writeLines("Calculating FSTs, may take a few minutes...")
nloci <- length(locusname)
FSTmat <- matrix(NA, nrow = nloci, ncol = 8)
for (i in 1:nloci) {
FSTmat[i, ] = unlist(getFSTs_diploids(popname, SNPmat[,i]))
if (i%%10000 == 0) {
print(paste(i, "done of", nloci))
}
}
outTemp = as.data.frame(FSTmat)
outTemp = cbind(locusname, outTemp)
colnames(outTemp) = c("LocusName", "He", "FST", "T1", "T2",
"FSTNoCorr", "T1NoCorr", "T2NoCorr", "meanAlleleFreq")
return(outTemp)
}
Pfst<-MakeDiploidFSTMat_2(SNPmat = Gtf, locusNames = colnames(Gtf), popNames = PopsALL)
(Max <- max(Pfst$FST, na.rm=T))
(Min <- min(Pfst$FST, na.rm = T))
CHR_data <- data.frame (SNP = Pfst$LocusName , CHR=position_inv, BP= position_scaled, P=Pfst$FST)
# Plot !
manhattan(CHR_data , ylim=c(Min-(Min*0.1),Max+(Max*0.1)), suggestiveline = F, genomewideline = F , logp=F, col=brewer.pal(5, "Set2") , main="Silverside simulation\nm=0.001, r=(1e-5)x4, 1e-6, 1e-4", ylab=expression(paste("F"[ST])))
lines(x=c(34750,104250),y=c(Min-(Min*0.1),Min-(Min*0.1)),col="red",lwd=2)
lines(x=c(173750,243250),y=c(Min-(Min*0.1),Min-(Min*0.1)),col="red",lwd=2)
lines(x=c(312750,382250),y=c(Min-(Min*0.1),Min-(Min*0.1)),col="red",lwd=2)
abline(v=c(34750,104250,173750,243250,312750,382250), col="red")
position_scaled
tail(position_scaled)
head(position_scaled)
tail(position_inv)
head(position_inv)
ggplot(data=map_sum_merged[map_sum_merged$Mean_depth<20 & map_sum_merged$reads>10,])+
geom_point(aes(x=Mean_depth, y=per_duplicates, col=Library, shape=Type), size=5)+
xlab("Mean depth")+
ylab("Percent duplicates")+
scale_color_manual(values=c("red", "orange", "green", "cyan", "violet", "blue"))+
theme_classic()
require(ggplot2)
setwd("E:/Research_AJL/Cornell/library-test/demultiplexed/")
source('E:/Research_AJL/Cornell/library-test/demultiplexed/trimmed_filtered_viz.R')
map_sum_merged
ggplot(data=map_sum_merged[map_sum_merged$Mean_depth<20 & map_sum_merged$reads>10,])+
geom_point(aes(x=Mean_depth, y=per_duplicates, col=Library, shape=Type), size=5)+
xlab("Mean depth")+
ylab("Percent duplicates")+
scale_color_manual(values=c("red", "orange", "green", "cyan", "violet", "blue"))+
theme_classic()
ggplot(data=map_summary[map_summary$Mean_depth<20,])+
geom_point(aes(x=Mean_depth, y=Per_ref_cov, col=Library, shape=Type), size=5)+
xlab("Mean depth")+
ylab("Percent ref. covered")+
scale_color_manual(values=c("red", "orange", "green", "cyan", "violet", "blue"))+
theme_classic()
ggplot(data=map_summary[map_summary$Mean_depth<20& map_summary$reads>10,,])+
geom_point(aes(x=Mean_depth, y=Per_ref_cov, col=Library, shape=Type), size=5)+
xlab("Mean depth")+
ylab("Percent ref. covered")+
scale_color_manual(values=c("red", "orange", "green", "cyan", "violet", "blue"))+
theme_classic()
ggplot(data=map_summary[map_summary$Mean_depth<20& map_summary$reads>10,])+
geom_point(aes(x=Mean_depth, y=Per_ref_cov, col=Library, shape=Type), size=5)+
xlab("Mean depth")+
ylab("Percent ref. covered")+
scale_color_manual(values=c("red", "orange", "green", "cyan", "violet", "blue"))+
theme_classic()
map_summary
ggplot(data=map_sum_merged[map_sum_merged$Mean_depth<20 & map_sum_merged$reads>10,])+
geom_point(aes(x=Mean_depth, y=Per_ref_cov, col=Library, shape=Type), size=5)+
xlab("Mean depth")+
ylab("Percent ref. covered")+
scale_color_manual(values=c("red", "orange", "green", "cyan", "violet", "blue"))+
theme_classic()
ggplot(data=map_sum_merged[map_sum_merged$reads>10,])+
geom_point(aes(x=Mean_depth, y=Per_ref_cov, col=Library, shape=Type), size=5)+
xlab("Mean depth")+
ylab("Percent ref. covered")+
scale_color_manual(values=c("red", "orange", "green", "cyan", "violet", "blue"))+
theme_classic()
ggplot(data=map_sum_merged[map_sum_merged$Mean_depth<20 & map_sum_merged$reads>10,])+
geom_point(aes(x=Mean_depth, y=per_duplicates, col=Library, shape=Type), size=5)+
xlab("Mean depth")+
ylab("Percent duplicates")+
scale_color_manual(values=c("red", "orange", "green", "cyan", "violet", "blue"))+
theme_classic()
ggplot(data=map_sum_merged[map_sum_merged$Mean_depth<20 & map_sum_merged$reads>10,])+
geom_point(aes(x=Mean_depth, y=Per_ref_cov, col=Library, shape=Type), size=5)+
xlab("Mean depth")+
ylab("Percent ref. covered")+
scale_color_manual(values=c("red", "orange", "green", "cyan", "violet", "blue"))+
theme_classic()
ggplot(data=trim[seq(2,nrow(trim),2),], aes(x = Type, y= Difference, fill=Library))+
geom_boxplot()+
ylab("Adapter sequence trimmed")+
xlab("Data type")+
theme_classic()
ggplot(data=trim[seq(2,nrow(trim),2),], aes(x = Type, y= Per_Diff, fill=Library))+
geom_boxplot()+
ylab("Adapter sequence trimmed\nas proportion of raw sequence")+
xlab("Data type")+
theme_classic()
map_sum_merged_all <- merge(map_sum_merged, trim, by="Ind")
ggplot(data=map_sum_merged_all[map_sum_merged_all$Mean_depth<20,])+
geom_point(aes(x=Mean_depth, y=No_nuc, col=Library.x, shape=Type.x), size=5)+
xlab("Mean depth")+
ylab("Raw read length")+
theme_classic()
View(trim)
colnames(map_sum_merged_all)
View(map_sum_merged_all)
View(trim)
colnames(trim)
trim[trim$File=="Raw",]
trim[trim$File=="Raw",] %>%
group_by(Ind) %>%
summarise(Sum = sum(No_nuc))
library(tidyverse)
trim[trim$File=="Raw",] %>%
group_by(Ind) %>%
summarise(Sum = sum(No_nuc))
trim[trim$File=="Raw",] %>%
group_by(Ind, Lib, Type) %>%
summarise(Sum = sum(No_nuc))
trim[trim$File=="Raw",] %>%
group_by(Ind, Library, Type) %>%
summarise(Sum = sum(No_nuc))
trim_sum <- trim[trim$File=="Raw",] %>%
group_by(Ind, Library, Type) %>%
summarise(Sum = sum(No_nuc))
map_sum_merged_all_final <- merge(map_sum_merged_all, trim_sum, by="Ind")
View(map_sum_merged_all_final)
ggplot(data=map_sum_merged_all_final[map_sum_merged_all_final$Mean_depth<20,])+
geom_point(aes(x=Mean_depth, y=Sum, col=Library.x, shape=Type.x), size=5)+
xlab("Mean depth")+
ylab("Raw read length")+
theme_classic()
trim <- read.table("adapter_trim.tsv")
library(tidyverse)
require(ggplot2)
setwd("E:/Research_AJL/Cornell/library-test/demultiplexed/")
trim <- read.table("adapter_trim.tsv")
trim <- trim[,-2]
colnames(trim) <- c("Seq",	"No_nuc",	"Per_A",	"Per_C",	"Per_G",	"Per_T"	,"Per_N",	"Avg_Q",	"Err_Q"	,"Per_low","Per_high")
trim <- read.table("adapter_trim.tsv")
trim[,2]
setwd("E:/Research_AJL/Cornell/library-test/demultiplexed/")
nuc <- read.csv("NucCount_tot.csv")
nuc_pre <- nuc[grep("_paired",nuc$Dir, invert = T),]
nuc_trim <- nuc[grep("_paired",nuc$Dir),]
nuc_trim$Diff <- nuc_pre$No_nuc - nuc_trim$No_nuc
ggplot(data=nuc, aes(x = Ind, y=No_nuc, fill=Lib))+
geom_bar(stat="identity")+
ylab("Nucleotides")+
xlab("")+
theme_classic()
ggplot(data=nuc, aes(x = Ind, y=log(No_nuc), fill=Lib))+
geom_boxplot()+
ylab("log(Nucleotides)")+
xlab("")+
theme_classic()
ggplot(data=nuc, aes(x = Cat, y=No_nuc, fill=Lib))+
geom_bar(stat="identity")+
ylab("Nucleotides")+
xlab("")+
theme_classic()
ggplot(data=nuc, aes(x = Cat, y=log(No_nuc), fill=Lib))+
geom_boxplot()+
ylab("log(Nucleotides)")+
xlab("")+
theme_classic()
ggplot(data=nuc, aes(x = Ind, y=Avg_Q, fill=Lib))+
geom_boxplot()+
ylab("Average quality score")+
xlab("")+
theme_classic()
ggplot(data=nuc, aes(x = Cat, y=Avg_Q, fill=Lib))+
geom_boxplot()+
ylab("Average quality score")+
xlab("")+
theme_classic()
ggplot(data=nuc, aes(x = Ind, y=Err_Q, fill=Lib))+
geom_boxplot()+
ylab("Base call error")+
xlab("")+
theme_classic()
ggplot(data=nuc, aes(x = Cat, y=Err_Q, fill=Lib))+
geom_boxplot()+
ylab("Base call error")+
xlab("")+
theme_classic()
ggplot(data=nuc, aes(x = Ind, y=Per_high, fill=Lib))+
geom_boxplot()+
ylab("Percent nucleotides high quality (Q>20)")+
xlab("")+
theme_classic()
ggplot(data=nuc, aes(x = Cat, y=Per_high, fill=Lib))+
geom_boxplot()+
ylab("Percent nucleotides high quality (Q>20)")+
xlab("")+
theme_classic()
trim <- read.table("adapter_trim.tsv")
trim <- trim[,-2]
colnames(trim) <- c("Seq",	"No_nuc",	"Per_A",	"Per_C",	"Per_G",	"Per_T"	,"Per_N",	"Avg_Q",	"Err_Q"	,"Per_low","Per_high")
Sample <- substr(trim$Seq, 1,5)
Sample <- gsub("_[A-Za-z]", "", Sample)
Sample
Library <- c(rep("BEST", 120),rep("Chan", 64),rep("Desai", 120),rep("NEBnext", 120),rep("Hackflex",8),rep("PCRfree",8),rep("Hackflex",4),rep("PCRfree",4),rep("Hackflex",4))
Type<-c(rep("DegDNA_modern", 16),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("HMW_lc", 4),rep("HMW_hc", 4),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("HMW_lc", 4),rep("HMW_hc", 4),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("HMW_lc", 4),rep("HMW_hc", 4),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("HMW_lc", 4),rep("HMW_hc", 4),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("HMW_lc", 4),rep("HMW_hc", 4),rep("DegDNA_ancient", 24),rep("DegDNA_modern", 8),rep("HMW_lc", 4),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("DegDNA_ancient", 12),rep("DegDNA_modern", 16),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("HMW_lc", 4),rep("HMW_hc", 4),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("HMW_lc", 4),rep("HMW_hc", 4),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("HMW_lc", 4),rep("HMW_hc", 4),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("HMW_lc", 4),rep("HMW_hc", 4),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("HMW_lc", 4),rep("HMW_hc", 4),rep("DegDNA_ancient", 24),rep("DegDNA_modern", 16),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("HMW_lc", 4),rep("HMW_hc", 4),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("HMW_lc", 4),rep("HMW_hc", 4),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("HMW_lc", 4),rep("HMW_hc", 4),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("HMW_lc", 4),rep("HMW_hc", 4),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("HMW_lc", 4),rep("HMW_hc", 4),rep("DegDNA_ancient", 24),rep("HMW_hc", 4),rep("HMW_lc", 4),rep("HMW", 8),rep("HMW_hc", 4),rep("HMW", 4),rep("DegDNA_ancient", 4))
length(Library)
length(Type)
length(Type2)
View(map_sum_merged_all)
View(map_sum_merged)
Type2<-c(rep("API_BEST", 8),rep("DAB_BEST", 8),rep("ITV28_hc_BEST", 4),rep("ITV28_lc_BEST", 4),rep("ITV28_lc_BEST", 4),rep("ITV28_hc_BEST", 4),rep("ITV36_hc_BEST", 4),rep("ITV36_lc_BEST", 4),rep("ITV36_lc_BEST", 4),rep("ITV36_hc_BEST", 4),rep("ITV42_hc_BEST", 4),rep("ITV42_lc_BEST", 4),rep("ITV42_lc_BEST", 4),rep("ITV42_hc_BEST", 4),rep("ITV46_hc_BEST", 4),rep("ITV46_lc_BEST", 4),rep("ITV46_lc_BEST", 4),rep("ITV46_hc_BEST", 4),rep("ITV48_hc_BEST", 4),rep("ITV48_lc_BEST", 4),rep("ITV48_lc_BEST", 4),rep("ITV48_hc_BEST", 4),rep("T4_02_BEST", 8),rep("T4_11_BEST", 8),rep("T4_32_BEST", 8),rep("API_Chan", 4),rep("DAB_Chan", 4),rep("ITV36_lc_Chan", 4),rep("ITV28_hc_Chan", 4),rep("ITV28_lc_Chan", 4),rep("ITV36_hc_Chan", 4),rep("ITV36_lc_Chan", 4),rep("ITV42_hc_Chan", 4),rep("ITV42_lc_Chan", 4),rep("ITV46_hc_Chan", 4),rep("ITV46_lc_Chan", 4),rep("ITV48_hc_Chan", 4),rep("ITV48_lc_Chan", 4),rep("T4_02_Chan", 4),rep("T4_11_Chan", 4),rep("T4_32_Chan", 4),rep("API_Desai", 8),rep("DAB_Desai", 8),rep("ITV28_hc_Desai", 4),rep("ITV28_lc_Desai", 4),rep("ITV28_lc_Desai", 4),rep("ITV28_hc_Desai", 4),rep("ITV36_hc_Desai", 4),rep("ITV36_lc_Desai", 4),rep("ITV36_lc_Desai", 4),rep("ITV36_hc_Desai", 4),rep("ITV42_hc_Desai", 4),rep("ITV42_lc_Desai", 4),rep("ITV42_lc_Desai", 4),rep("ITV42_hc_Desai", 4),rep("ITV46_hc_Desai", 4),rep("ITV46_lc_Desai", 4),rep("ITV46_lc_Desai", 4),rep("ITV46_hc_Desai", 4),rep("ITV48_hc_Desai", 4),rep("ITV48_lc_Desai", 4),rep("ITV48_lc_Desai", 4),rep("ITV48_hc_Desai", 4),rep("T4_02_Desai", 8),rep("T4_11_Desai", 8),rep("T4_32_Desai", 8),rep("API_NEBnext", 8),rep("DAB_NEBnext", 8),rep("ITV28_hc_NEBnext", 4),rep("ITV28_lc_NEBnext", 4),rep("ITV28_lc_NEBnext", 4),rep("ITV28_hc_NEBnext", 4),rep("ITV36_hc_NEBnext", 4),rep("ITV36_lc_NEBnext", 4),rep("ITV36_lc_NEBnext", 4),rep("ITV36_hc_NEBnext", 4),rep("ITV42_hc_NEBnext", 4),rep("ITV42_lc_NEBnext", 4),rep("ITV42_lc_NEBnext", 4),rep("ITV42_hc_NEBnext", 4),rep("ITV46_hc_NEBnext", 4),rep("ITV46_lc_NEBnext", 4),rep("ITV46_lc_NEBnext", 4),rep("ITV46_hc_NEBnext", 4),rep("ITV48_hc_NEBnext", 4),rep("ITV48_lc_NEBnext", 4),rep("ITV48_lc_NEBnext", 4),rep("ITV48_hc_NEBnext", 4),rep("T4_02_NEBnext", 8),rep("T4_11_NEBnext", 8),rep("T4_32_NEBnext", 8),rep("ITV28_hc_HF",4),rep( "ITV36_lc_HF",4),rep( "ITV36_PF",4),rep("ITV42_PF",4),rep( "ITV48_hc_HF"),rep("ITV48_PF",4),rep("T4_32_HF",4))
length(Type2)
length(Type)
Type2<-c(rep("API_BEST", 8),rep("DAB_BEST", 8),rep("ITV28_hc_BEST", 4),rep("ITV28_lc_BEST", 4),rep("ITV28_lc_BEST", 4),rep("ITV28_hc_BEST", 4),rep("ITV36_hc_BEST", 4),rep("ITV36_lc_BEST", 4),rep("ITV36_lc_BEST", 4),rep("ITV36_hc_BEST", 4),rep("ITV42_hc_BEST", 4),rep("ITV42_lc_BEST", 4),rep("ITV42_lc_BEST", 4),rep("ITV42_hc_BEST", 4),rep("ITV46_hc_BEST", 4),rep("ITV46_lc_BEST", 4),rep("ITV46_lc_BEST", 4),rep("ITV46_hc_BEST", 4),rep("ITV48_hc_BEST", 4),rep("ITV48_lc_BEST", 4),rep("ITV48_lc_BEST", 4),rep("ITV48_hc_BEST", 4),rep("T4_02_BEST", 8),rep("T4_11_BEST", 8),rep("T4_32_BEST", 8),rep("API_Chan", 4),rep("DAB_Chan", 4),rep("ITV36_lc_Chan", 4),rep("ITV28_hc_Chan", 4),rep("ITV28_lc_Chan", 4),rep("ITV36_hc_Chan", 4),rep("ITV36_lc_Chan", 4),rep("ITV42_hc_Chan", 4),rep("ITV42_lc_Chan", 4),rep("ITV46_hc_Chan", 4),rep("ITV46_lc_Chan", 4),rep("ITV48_hc_Chan", 4),rep("ITV48_lc_Chan", 4),rep("T4_02_Chan", 4),rep("T4_11_Chan", 4),rep("T4_32_Chan", 4),rep("API_Desai", 8),rep("DAB_Desai", 8),rep("ITV28_hc_Desai", 4),rep("ITV28_lc_Desai", 4),rep("ITV28_lc_Desai", 4),rep("ITV28_hc_Desai", 4),rep("ITV36_hc_Desai", 4),rep("ITV36_lc_Desai", 4),rep("ITV36_lc_Desai", 4),rep("ITV36_hc_Desai", 4),rep("ITV42_hc_Desai", 4),rep("ITV42_lc_Desai", 4),rep("ITV42_lc_Desai", 4),rep("ITV42_hc_Desai", 4),rep("ITV46_hc_Desai", 4),rep("ITV46_lc_Desai", 4),rep("ITV46_lc_Desai", 4),rep("ITV46_hc_Desai", 4),rep("ITV48_hc_Desai", 4),rep("ITV48_lc_Desai", 4),rep("ITV48_lc_Desai", 4),rep("ITV48_hc_Desai", 4),rep("T4_02_Desai", 8),rep("T4_11_Desai", 8),rep("T4_32_Desai", 8),rep("API_NEBnext", 8),rep("DAB_NEBnext", 8),rep("ITV28_hc_NEBnext", 4),rep("ITV28_lc_NEBnext", 4),rep("ITV28_lc_NEBnext", 4),rep("ITV28_hc_NEBnext", 4),rep("ITV36_hc_NEBnext", 4),rep("ITV36_lc_NEBnext", 4),rep("ITV36_lc_NEBnext", 4),rep("ITV36_hc_NEBnext", 4),rep("ITV42_hc_NEBnext", 4),rep("ITV42_lc_NEBnext", 4),rep("ITV42_lc_NEBnext", 4),rep("ITV42_hc_NEBnext", 4),rep("ITV46_hc_NEBnext", 4),rep("ITV46_lc_NEBnext", 4),rep("ITV46_lc_NEBnext", 4),rep("ITV46_hc_NEBnext", 4),rep("ITV48_hc_NEBnext", 4),rep("ITV48_lc_NEBnext", 4),rep("ITV48_lc_NEBnext", 4),rep("ITV48_hc_NEBnext", 4),rep("T4_02_NEBnext", 8),rep("T4_11_NEBnext", 8),rep("T4_32_NEBnext", 8),rep("ITV28_hc_HF",4),rep( "ITV36_lc_HF",4),rep( "ITV36_PF",4),rep("ITV42_PF",4),rep("ITV48_hc_HF",4),rep("ITV48_PF",4),rep( "T4_32_HF",4))
length(Type)
length(Type2)
trim$Library <- Library
trim$Type <- Type
trim$Ind <- Type2
trim$File <- rep(c("Raw", "Trimmed"),nrow(trim)/2)
Difference <- NULL
Per_Diff <- NULL
for(i in seq(2,nrow(trim),2)){
Difference <- c(Difference,0,trim[i-1,2]-trim[i,2])
Per_Diff <- c(Per_Diff,0,(trim[i-1,2]-trim[i,2])/trim[i-1,2])
}
trim$Difference <- Difference
trim$Per_Diff <- Per_Diff
ggplot(data=trim[seq(2,nrow(trim),2),], aes(x = Type, y= Difference, fill=Library))+
geom_boxplot()+
ylab("Adapter sequence trimmed")+
xlab("Data type")+
theme_classic()
ggplot(data=trim[seq(2,nrow(trim),2),], aes(x = Type, y= Per_Diff, fill=Library))+
geom_boxplot()+
ylab("Adapter sequence trimmed\nas proportion of raw sequence")+
xlab("Data type")+
theme_classic()
trim_sum <- trim[trim$File=="Raw",] %>%
group_by(Ind, Library, Type) %>%
summarise(Sum = sum(No_nuc))
trim_sum
trim_sum$Library
trim_sum$Ind
map_sum_merged_all$Ind
map_sum_merged$Ind
trim$Ind
map_sum_merged_all <- merge(map_sum_merged, trim, by="Ind")
map_sum_merged_all_final <- merge(map_sum_merged_all, trim_sum, by="Ind")
View(map_sum_merged_all_final)
ggplot(data=map_sum_merged_all_final[map_sum_merged_all_final$Mean_depth<20,])+
geom_point(aes(x=Mean_depth, y=Sum, col=Library.x, shape=Type.x), size=5)+
xlab("Mean depth")+
ylab("Raw read length")+
theme_classic()
View(map_sum_merged_all_final)
require(vcfR)
require(OutFLANK)
require(qqman)
require(RColorBrewer)
ssvcf <- read.vcfR("1614647548037_Silverside_Inversion.vcf")
setwd("E:/Research_AJL/Cornell/silverside-simulation/")
require(vcfR)
require(OutFLANK)
require(qqman)
require(RColorBrewer)
ssvcf <- read.vcfR("1614647548037_Silverside_Inversion.vcf")
ssvcf_clean <- ssvcf[-grep("MT=[2-4]",ssvcf@fix[,8])]
geno <- ssvcf_clean@gt[,-1] # Remove 1st column, which is 'Format'
position <- as.numeric(getPOS(ssvcf_clean)) # Positions in bp
# for(i in 1:length(position)){
#   if(position[i]>34750 & position[i]<104250){
#     position[i]<-104250-position[i]+34750
#   }
#   if(position[i]>173750 & position[i]<243250){
#     position[i]<-243250-position[i]+173750
#       }
#   if(position[i]>312750 & position[i]<382250){
#     position[i]<-382250-position[i]+312750
#       }
# }
G1 <- matrix(NA, nrow = nrow(geno), ncol = ncol(geno))
G1[geno %in% c("0/0", "0|0")] <- 0
G1[geno %in% c("0/1", "1/0", "1|0", "0|1")] <- 1
G1[geno %in% c("1/1", "1|1")] <- 2
Gt<-t(G1)
colnames(Gt)<-paste("M",position,sep="")
PopsALL <- NULL
for(j in rep(1:2)){
for(i in rep(j,100)){
PopsALL <- c(PopsALL,i)
}
}
position_inv<-NULL
position_scaled<-NULL
for(i in 1:length(position)){
if(position[i]>0 & position[i]<139001){
position_inv<-c(position_inv,1)
position_scaled<-c(position_scaled,position[i])
}
if(position[i]>139000 & position[i]<278001){
position_inv<-c(position_inv,2)
position_scaled<-c(position_scaled,position[i]-139000)
}
if(position[i]>278000 & position[i]<417001){
position_inv<-c(position_inv,3)
position_scaled<-c(position_scaled,position[i]-278000)
}
if(position[i]>417000 & position[i]<556001){
position_inv<-c(position_inv,4)
position_scaled<-c(position_scaled,position[i]-417000)
}
if(position[i]>556000 & position[i]<695001){
position_inv<-c(position_inv,5)
position_scaled<-c(position_scaled,position[i]-556000)
}
if(position[i]>695000 & position[i]<834001){
position_inv<-c(position_inv,6)
position_scaled<-c(position_scaled,position[i]-695000)
}
}
Gtf <- data.frame(Gt)
getFSTs_diploids = function(popNameList, SNPDataColumn){
#eliminating the missing data for this locus
popnames=unlist(as.character(popNameList))
popNameTemp=popnames[which(SNPDataColumn!=9)]
snpDataTemp=SNPDataColumn[SNPDataColumn!=9]
HetCounts <- tapply(snpDataTemp, list(popNameTemp,snpDataTemp), length)
HetCounts[is.na(HetCounts)] = 0
#Case: all individuals are genetically identical at this locus
if(dim(HetCounts)[2]==1){
return (list(He=NA,FST=NA, T1=NA, T2=NA,FSTNoCorr=NA, T1NoCorr=NA, T2NoCorr=NA,meanAlleleFreq = NA))
}
if(dim(HetCounts)[2]==2){
if(paste(colnames(HetCounts),collapse="")=="01"){HetCounts=cbind(HetCounts,"2"=0)}
if(paste(colnames(HetCounts),collapse="")=="12"){HetCounts=cbind("0"=0,HetCounts)}
if(paste(colnames(HetCounts),collapse="")=="02"){HetCounts=cbind(HetCounts[,1],"1"=0, HetCounts[,2])}
}
out = WC_FST_Diploids_2Alleles(HetCounts)
return(out)
}
MakeDiploidFSTMat_2<-function(SNPmat,locusNames,popNames){
locusname <- unlist(locusNames)
popname <- unlist(popNames)
snplevs <- levels(as.factor(unlist(SNPmat)))
if(any(!(snplevs%in%c(0,1,2,9)))==TRUE) {
print("Error: Your snp matrix has a character other than 0,1,2 or 9")
break
}
if (dim(SNPmat)[1] != length(popname)) {
print("Error: your population names do not match your SNP matrix")
break
}
if (dim(SNPmat)[2] != length(locusname)) {
print("Error:  your locus names do not match your SNP matrix")
break
}
writeLines("Calculating FSTs, may take a few minutes...")
nloci <- length(locusname)
FSTmat <- matrix(NA, nrow = nloci, ncol = 8)
for (i in 1:nloci) {
FSTmat[i, ] = unlist(getFSTs_diploids(popname, SNPmat[,i]))
if (i%%10000 == 0) {
print(paste(i, "done of", nloci))
}
}
outTemp = as.data.frame(FSTmat)
outTemp = cbind(locusname, outTemp)
colnames(outTemp) = c("LocusName", "He", "FST", "T1", "T2",
"FSTNoCorr", "T1NoCorr", "T2NoCorr", "meanAlleleFreq")
return(outTemp)
}
Pfst<-MakeDiploidFSTMat_2(SNPmat = Gtf, locusNames = colnames(Gtf), popNames = PopsALL)
(Max <- max(Pfst$FST, na.rm=T))
(Min <- min(Pfst$FST, na.rm = T))
CHR_data <- data.frame (SNP = Pfst$LocusName , CHR=position_inv, BP= position_scaled, P=Pfst$FST)
# Plot !
manhattan(CHR_data , ylim=c(Min-(Min*0.1),Max+(Max*0.1)), suggestiveline = F, genomewideline = F , logp=F, col=brewer.pal(5, "Set2") , main="Silverside simulation\nm=0.001, r=(1e-5)x4, 1e-6, 1e-4", ylab=expression(paste("F"[ST])))
lines(x=c(34750,104250),y=c(Min-(Min*0.1),Min-(Min*0.1)),col="red",lwd=2)
lines(x=c(173750,243250),y=c(Min-(Min*0.1),Min-(Min*0.1)),col="red",lwd=2)
lines(x=c(312750,382250),y=c(Min-(Min*0.1),Min-(Min*0.1)),col="red",lwd=2)
abline(v=c(34750,104250,173750,243250,312750,382250), col="red")
ggplot(data=map_sum_merged_all_final[map_sum_merged_all_final$Mean_depth<20,])+
geom_point(aes(x=Mean_depth, y=Sum, col=Library.x, shape=Type.x), size=5)+
scale_color_manual(values=c("red", "orange", "green", "cyan", "violet", "blue"))+
xlab("Mean depth")+
ylab("Raw read length")+
theme_classic()
dim(Gt)
PopsALL <- NULL
for(j in rep(1:2)){
for(i in rep(j,5000)){
PopsALL <- c(PopsALL,i)
}
}
Pfst<-MakeDiploidFSTMat_2(SNPmat = Gtf, locusNames = colnames(Gtf), popNames = PopsALL)
(Max <- max(Pfst$FST, na.rm=T))
(Min <- min(Pfst$FST, na.rm = T))
CHR_data <- data.frame (SNP = Pfst$LocusName , CHR=position_inv, BP= position_scaled, P=Pfst$FST)
# Plot !
manhattan(CHR_data , ylim=c(Min-(Min*0.1),Max+(Max*0.1)), suggestiveline = F, genomewideline = F , logp=F, col=brewer.pal(5, "Set2") , main="Silverside simulation\nm=0.001, r=(1e-5)x4, 1e-6, 1e-4", ylab=expression(paste("F"[ST])))
lines(x=c(34750,104250),y=c(Min-(Min*0.1),Min-(Min*0.1)),col="red",lwd=2)
lines(x=c(173750,243250),y=c(Min-(Min*0.1),Min-(Min*0.1)),col="red",lwd=2)
lines(x=c(312750,382250),y=c(Min-(Min*0.1),Min-(Min*0.1)),col="red",lwd=2)
abline(v=c(34750,104250,173750,243250,312750,382250), col="red")
